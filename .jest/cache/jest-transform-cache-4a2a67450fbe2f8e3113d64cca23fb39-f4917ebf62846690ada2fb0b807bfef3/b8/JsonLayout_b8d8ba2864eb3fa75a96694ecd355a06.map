{"version":3,"sources":["/home/muzzamil/Documents/bluebase/plugin-json-schema-components/src/JsonLayout/JsonLayout.tsx"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AAmBA,IAAM,YAAY,GAAG,SAAf,YAAe,CAAC,EAAD,EAAiB;AACrC,SAAO,gBAAqC;AAAA,QAAlC,SAAkC,QAAlC,SAAkC;AAE3C,WAAO,EAAE,CAAC,UAAH,CAAc,GAAd,CAAkB,MAAM,CAAC,SAAD,CAAxB,IAAuC,EAAE,CAAC,UAAH,CAAc,OAAd,CAAsB,MAAM,CAAC,SAAD,CAA5B,CAAvC,GAAkF,IAAzF;AACA,GAHD;AAIA,CALD;;IAiCa,U;;;;;;;;;;6BAIN;AAEL,UAAM,EAAE,GAAa,KAAK,OAA1B;AAFK,wBAI4B,KAAK,KAJjC;AAAA,UAIG,MAJH,eAIG,MAJH;AAAA,UAIW,MAJX,eAIW,MAJX;AAAA,UAImB,IAJnB,eAImB,IAJnB;AAKL,UAAM,MAAM,GAAG,IAAI,KAAA,CAAA,gBAAJ,CAAqB,YAAY,CAAC,EAAD,CAAjC,CAAf;;AAGA,UAAI,CAAC,MAAL,EAAa;AACZ,eAAO,MAAM,CAAC,WAAP,CAAmB,MAAnB,CAAP;AACA;;AAED,UAAM,QAAQ,GAAG,SAAX,QAAW,CAAC,YAAD;AAAA,eAAiD,MAAM,CAAC,WAAP,CAAmB,YAAnB,CAAjD;AAAA,OAAjB;;AAEA,aACC,OAAA,CAAA,OAAA,CAAA,aAAA,CAAC,MAAA,CAAA,cAAD,EAAe;AACd,QAAA,MAAM,EAAE,MADM;AAEd,QAAA,KAAK,EAAE,MAFO;AAGd,QAAA,IAAI,EAAE,IAHQ;AAId,QAAA,QAAQ,EAAE;AAJI,OAAf,CADD;AAQA;;;EA1B8B,OAAA,CAAA,OAAA,CAAM,a;;AAE9B,UAAA,CAAA,WAAA,GAAc,MAAA,CAAA,eAAd;AAFR,OAAA,CAAA,UAAA,GAAA,UAAA","sourcesContent":["import { BlueBase, BlueBaseContext, BlueBaseFilter, MaybeArray } from '@bluebase/core';\nimport { JsonComponentNode, JsonSchemaParser } from '../lib';\nimport React from 'react';\n\nexport interface JsonLayoutProps {\n\n\t/** JSON Schema. */\n\tschema: MaybeArray<JsonComponentNode>;\n\n\t/** Event name to filter this schema. If this is not provided, the schema is not filtered. */\n\tfilter?: string;\n\n\t/** Arguments for the filter. */\n\targs?: { [key: string]: any };\n\n  /**\n   * Used to locate this view in end-to-end tests.\n   */\n\ttestID?: string,\n}\n\nconst getComponent = (BB: BlueBase) => {\n\treturn ({ component }: JsonComponentNode) => {\n\n\t\treturn BB.Components.has(String(component)) ? BB.Components.resolve(String(component)) : null;\n\t};\n};\n\n/**\n * # üç± JsonLayout\n *\n * Renders a Component based on JSON schema. This allows developers to create dynamic\n * layouts in their apps, and even save the schema to databases.\n *\n * Moreover, it also makes that schema filter-able. So that any plugin can modify that schema\n * on runtime.\n *\n * ## Usage:\n * ```jsx\n * <JsonLayout\n * \tfilter=\"content-filter\"\n * \targs={{ style: { color: 'blue' } }}\n *  schema={{\n * \t component: 'Text',\n * \t props: {\n * \t\t style: {\n * \t\t\t color: 'red'\n * \t\t }\n * \t },\n * \t text: 'This is the page content.',\n *  }\n * } />\n * ```\n */\nexport class JsonLayout extends React.PureComponent<JsonLayoutProps> {\n\n\tstatic contextType = BlueBaseContext;\n\n\trender() {\n\n\t\tconst BB: BlueBase = this.context;\n\n\t\tconst { filter, schema, args } = this.props;\n\t\tconst parser = new JsonSchemaParser(getComponent(BB));\n\n\t\t// There's no filter, we don't need to do complex async handling\n\t\tif (!filter) {\n\t\t\treturn parser.parseSchema(schema);\n\t\t}\n\n\t\tconst children = (loadedSchema: MaybeArray<JsonComponentNode>) => parser.parseSchema(loadedSchema);\n\n\t\treturn (\n\t\t\t<BlueBaseFilter\n\t\t\t\tfilter={filter}\n\t\t\t\tvalue={schema}\n\t\t\t\targs={args}\n\t\t\t\tchildren={children}\n\t\t\t/>\n\t\t);\n\t}\n}\n"]}